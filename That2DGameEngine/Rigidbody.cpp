#include "Rigidbody.h"

#include "Logger.h"
#include "Timer.h"

#include "GameObject.h"

#include "BoxCollider.h"
#include "Transform.h"
#include <iostream>

void that::Rigidbody::Init()
{
	// Retrieve the collider on this gameobject
	m_pCollider = GetOwner()->GetComponent<BoxCollider>();

	// Log an error if no collider is found
	if (m_pCollider == nullptr) Logger::LogError("GameObject has Rigidbody but no BoxCollider", GetOwner());

	// Listen to any collision events
	m_pCollider->OnCollision.AddListener(this);

	// Retrieve the start position
	m_Position = GetTransform()->GetWorldPosition();
}

void that::Rigidbody::OnFrameStart()
{
	// Reset the previous step
	m_PrevStep = {};
}

void that::Rigidbody::Update()
{
	// Get data
	float elapsedSec{ Timer::GetInstance().GetElapsed() };

	// Apply gravity
	if (m_HasGravity)
	{
		if (m_HasConstantGravity)
			m_Velocity.y = m_Gravity;
		else 
			m_Velocity.y += m_Gravity * elapsedSec;
	}

	// Apply the velocity
	Move(m_Velocity * elapsedSec);
}

void that::Rigidbody::Notify(const CollisionData& collision)
{
	const glm::vec2 collisionVelocity{ m_Velocity };

	ApplyFriction(collision, collisionVelocity);
	ApplyBounce(collision, collisionVelocity);

	if (!m_HasCollisionCorrection) return;

	// Revert the previous movement
	m_Position += collision.fixStep;

	// Apply the position
	GetTransform()->SetWorldPosition(m_Position);
}

void that::Rigidbody::SetPosition(const glm::vec2 position, bool world)
{
	// Overwrite the current position
	if (world)
		m_Position = position;
	else
	{
		GameObject* pParent{ GetOwner()->GetParent() };

		if (pParent) m_Position = position + pParent->GetTransform()->GetWorldPosition();
		else m_Position = position;
	}

	// Apply the position
	GetTransform()->SetWorldPosition(m_Position);

	// Cancel out any movement the rigidbody might have done previous update
	m_PrevStep = {};
	m_Velocity = {};
}

void that::Rigidbody::Move(const glm::vec2 step)
{
	// Keep track of the velocity on update
	// We might need it again to revert this on collision
	m_PrevStep += step;

	// Apply velocity
	m_Position += step;

	// Apply the position
	GetTransform()->SetWorldPosition(m_Position);
}

void that::Rigidbody::Reset()
{
	m_Velocity = {};
	m_PrevStep = {};
}

void that::Rigidbody::AddForce(const glm::vec2& force, ForceMode mode)
{
	switch (mode)
	{
	case ForceMode::Force:
	{
		// Calculate the velocity using F = m * a = m * v / t => v = (F * t) / m
		m_Velocity += force * that::Timer::GetInstance().GetElapsed() / m_Mass;
		break;
	}
	case ForceMode::Impulse:
	{
		// Calculate the velocity using F = m * v => v = F / m
		m_Velocity += force / m_Mass;
		break;
	}
	}
}

void that::Rigidbody::ApplyFriction(const CollisionData& collision, const glm::vec2& collisionVelocity)
{
	// Calculate the contact normal
	const glm::vec2 contactNormal{ glm::normalize(collision.fixStep) };

	// Calculate the relative velocity
	glm::vec2 relativeVelocity{ collisionVelocity };
	if (Rigidbody* pOtherRb{ collision.pOther->GetOwner()->GetComponent<Rigidbody>() })
	{
		relativeVelocity -= pOtherRb->GetVelocity();
	}

	// Calculate the impulse of the collision
	const float impulse{ -glm::dot(relativeVelocity, contactNormal) };

	// Remove the relative velocity in the direction of the surface normal
	relativeVelocity += impulse * contactNormal;

	// If the velocity is 0, don't apply friction
	//	This would cause a runtime error when we try to normalize this vector (divide by 0)
	if (glm::dot(relativeVelocity, relativeVelocity) < FLT_EPSILON)
	{
		return;
	}

	// Calculate the friction between the two colliders
	float friction{ collision.pCollider->GetMaterial().friction };
	switch (collision.pCollider->GetMaterial().frictionMixer)
	{
	case PhysicsMaterial::PropertyMixer::Average:
		friction = (friction + collision.pOther->GetMaterial().friction) / 2.0f;
		break;
	case PhysicsMaterial::PropertyMixer::Minimum:
		friction = std::min(friction, collision.pOther->GetMaterial().friction);
		break;
	case PhysicsMaterial::PropertyMixer::Maximum:
		friction = std::max(friction, collision.pOther->GetMaterial().friction);
		break;
	case PhysicsMaterial::PropertyMixer::Multiply:
		friction = friction * collision.pOther->GetMaterial().friction;
		break;
	}

	// Calculate the maximum friction impulse
	const float currentImpulse{ glm::length(relativeVelocity) * m_Mass };

	// Calculate the friction impulse generated by the collision
	const float frictionImpulse{ friction * impulse };

	// Apply friction
	AddForce(std::min(frictionImpulse, currentImpulse) * -glm::normalize(relativeVelocity), that::Rigidbody::ForceMode::Impulse);
}

void that::Rigidbody::ApplyBounce(const CollisionData& collision, const glm::vec2& collisionVelocity)
{
	// Calculate the contact normal
	const glm::vec2 contactNormal{ glm::normalize(collision.fixStep) };

	// Calculate the relative velocity
	glm::vec2 relativeVelocity{ collisionVelocity };
	if (Rigidbody* pOtherRb{ collision.pOther->GetOwner()->GetComponent<Rigidbody>() })
	{
		relativeVelocity -= pOtherRb->GetVelocity();
	}

	// Only keep the relative velocity in the direction of the surface normal
	relativeVelocity = glm::dot(relativeVelocity, contactNormal) * contactNormal;

	// Calculate the impulse of the collision
	const float impulse{ -glm::dot(relativeVelocity, contactNormal) };

	// Calculate the elasticity between the two colliders
	float elasticity{ collision.pCollider->GetMaterial().elasticity };
	switch (collision.pCollider->GetMaterial().elasticityMixer)
	{
	case PhysicsMaterial::PropertyMixer::Average:
		elasticity = (elasticity + collision.pOther->GetMaterial().elasticity) / 2.0f;
		break;
	case PhysicsMaterial::PropertyMixer::Minimum:
		elasticity = std::min(elasticity, collision.pOther->GetMaterial().elasticity);
		break;
	case PhysicsMaterial::PropertyMixer::Maximum:
		elasticity = std::max(elasticity, collision.pOther->GetMaterial().elasticity);
		break;
	case PhysicsMaterial::PropertyMixer::Multiply:
		elasticity = elasticity * collision.pOther->GetMaterial().elasticity;
		break;
	}

	// Calculate the bounce impulse generated by the collision
	const float bounceImpulse{ (1.0f + elasticity) * impulse };

	// Apply bounce
	AddForce(bounceImpulse * contactNormal, that::Rigidbody::ForceMode::Impulse);
}
