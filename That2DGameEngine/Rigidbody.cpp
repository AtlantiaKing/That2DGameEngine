#include "Rigidbody.h"

#include "Logger.h"
#include "Timer.h"

#include "GameObject.h"

#include "BoxCollider.h"
#include "Transform.h"
#include <iostream>

void that::Rigidbody::Init()
{
	// Retrieve the collider on this gameobject
	m_pCollider = GetOwner()->GetComponent<BoxCollider>();

	// Log an error if no collider is found
	if (m_pCollider == nullptr) Logger::LogError("GameObject has Rigidbody but no BoxCollider", GetOwner());

	// Listen to any collision events
	m_pCollider->OnCollision.AddListener(this);

	// Retrieve the start position
	m_Position = GetTransform()->GetWorldPosition();
}

void that::Rigidbody::OnFrameStart()
{
	// Reset the previous step
	m_PrevStep = {};
}

void that::Rigidbody::Update()
{
	// Get data
	float elapsedSec{ Timer::GetInstance().GetElapsed() };

	// Apply gravity
	if (m_HasGravity)
	{
		if (m_HasConstantGravity)
			m_Velocity.y = m_Gravity;
		else 
			m_Velocity.y += m_Gravity * elapsedSec;
	}

	// Apply the velocity
	Move(m_Velocity * elapsedSec);
}

void that::Rigidbody::Notify(const CollisionData& collision)
{
	ApplyFriction(collision);

	// Reset the velocity
	const bool verticalCollision{ abs(collision.fixStep.y) > FLT_EPSILON };
	m_Velocity.x = !verticalCollision ? 0.0f : m_Velocity.x;
	m_Velocity.y = verticalCollision ? 0.0f : m_Velocity.y;

	if (!m_HasCollisionCorrection) return;

	// Revert the previous movement
	m_Position += collision.fixStep;

	// Apply the position
	GetTransform()->SetWorldPosition(m_Position);
}

void that::Rigidbody::SetPosition(const glm::vec2 position, bool world)
{
	// Overwrite the current position
	if (world)
		m_Position = position;
	else
	{
		GameObject* pParent{ GetOwner()->GetParent() };

		if (pParent) m_Position = position + pParent->GetTransform()->GetWorldPosition();
		else m_Position = position;
	}

	// Apply the position
	GetTransform()->SetWorldPosition(m_Position);

	// Cancel out any movement the rigidbody might have done previous update
	m_PrevStep = {};
	m_Velocity = {};
}

void that::Rigidbody::Move(const glm::vec2 step)
{
	// Keep track of the velocity on update
	// We might need it again to revert this on collision
	m_PrevStep += step;

	// Apply velocity
	m_Position += step;

	// Apply the position
	GetTransform()->SetWorldPosition(m_Position);
}

void that::Rigidbody::Reset()
{
	m_Velocity = {};
	m_PrevStep = {};
}

void that::Rigidbody::AddForce(const glm::vec2& force, ForceMode mode)
{
	switch (mode)
	{
	case ForceMode::Force:
	{
		// Calculate the velocity using F = m * a = m * v / t => v = (F * t) / m
		m_Velocity += force * that::Timer::GetInstance().GetElapsed() / m_Mass;
		break;
	}
	case ForceMode::Impulse:
	{
		// Calculate the velocity using F = m * v => v = F / m
		m_Velocity += force / m_Mass;
		break;
	}
	}
}

void that::Rigidbody::ApplyFriction(const CollisionData& collision)
{
	// Calculate the contact normal
	const glm::vec2 contactNormal{ glm::normalize(collision.fixStep) };

	// Calculate the relative velocity
	glm::vec2 relativeVelocity{ m_Velocity };
	if (Rigidbody* pOtherRb{ collision.pOther->GetOwner()->GetComponent<Rigidbody>() })
	{
		relativeVelocity -= pOtherRb->GetVelocity();
	}

	// Calculate the impulse of the collision
	const float impulse{ -glm::dot(relativeVelocity, contactNormal) };

	// Remove the relative velocity in the direction of the surface normal
	relativeVelocity += glm::dot(m_Velocity, contactNormal) * contactNormal;

	// If the velocity is 0, don't apply friction
	//	This would cause a runtime error when we try to normalize this vector (divide by 0)
	if (glm::dot(relativeVelocity, relativeVelocity) < FLT_EPSILON)
	{
		return;
	}

	// Calculate the friction between the two colliders
	float friction{ collision.pCollider->GetMaterial().friction };
	switch (collision.pCollider->GetMaterial().frictionMixer)
	{
	case PhysicsMaterial::FrictionMixer::Average:
		friction = (friction + collision.pOther->GetMaterial().friction) / 2.0f;
		break;
	case PhysicsMaterial::FrictionMixer::Minimum:
		friction = std::min(friction, collision.pOther->GetMaterial().friction);
		break;
	case PhysicsMaterial::FrictionMixer::Maximum:
		friction = std::max(friction, collision.pOther->GetMaterial().friction);
		break;
	case PhysicsMaterial::FrictionMixer::Multiply:
		friction = friction * collision.pOther->GetMaterial().friction;
		break;
	}

	// Calculate the maximum friction impulse
	const float objectMaxFrictionImpulse{ friction * m_Mass * m_Gravity }; // The maximum friction that this object is allowed to have
	const float currentImpulse{ glm::length(relativeVelocity) * m_Mass }; // The impulse depending on the current velocity
	const float maxFrictionImpulse{ std::min(objectMaxFrictionImpulse, currentImpulse) };

	// Calculate the friction impulse generated by the collision
	const float frictionImpulse{ friction * impulse };

	// Apply friction
	AddForce(std::min(frictionImpulse, maxFrictionImpulse) * -glm::normalize(relativeVelocity), that::Rigidbody::ForceMode::Impulse);
}
